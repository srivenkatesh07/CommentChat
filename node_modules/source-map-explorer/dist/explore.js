'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true,
});
exports.exploreBundle = exploreBundle;
exports.adjustSourcePaths = adjustSourcePaths;
exports.UNMAPPED_KEY = void 0;

var _convertSourceMap = _interopRequireDefault(require('convert-source-map'));

var _path = _interopRequireDefault(require('path'));

var _sourceMap = require('source-map');

var _lodash = require('lodash');

var _api = require('./api');

var _helpers = require('./helpers');

var _appError = require('./app-error');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

const UNMAPPED_KEY = '<unmapped>';
/**
 * Analyze a bundle
 */

exports.UNMAPPED_KEY = UNMAPPED_KEY;

async function exploreBundle(bundle, options) {
  const { code, map } = bundle;
  const sourceMapData = await loadSourceMap(code, map);
  const sizes = computeGeneratedFileSizes(sourceMapData);
  const files = adjustSourcePaths(sizes.files, options);
  const { totalBytes, unmappedBytes } = sizes;

  if (!options.onlyMapped) {
    files[UNMAPPED_KEY] = unmappedBytes;
  } // Free Wasm data

  sourceMapData.consumer.destroy();
  return {
    bundleName: (0, _api.getBundleName)(bundle),
    totalBytes,
    unmappedBytes,
    files,
  };
}

/**
 * Get source map
 */
async function loadSourceMap(codeFile, sourceMapFile) {
  const codeFileContent = (0, _helpers.getFileContent)(codeFile);
  let consumer;

  if (sourceMapFile) {
    const sourceMapFileContent = (0, _helpers.getFileContent)(sourceMapFile);
    consumer = await new _sourceMap.SourceMapConsumer(sourceMapFileContent);
  } else {
    // Try to read a source map from a 'sourceMappingURL' comment.
    let converter = _convertSourceMap.default.fromSource(codeFileContent);

    if (!converter && !Buffer.isBuffer(codeFile)) {
      converter = _convertSourceMap.default.fromMapFileSource(
        codeFileContent,
        _path.default.dirname(codeFile)
      );
    }

    if (!converter) {
      throw new _appError.AppError({
        code: 'NoSourceMap',
      });
    }

    consumer = await new _sourceMap.SourceMapConsumer(converter.toJSON());
  }

  if (!consumer) {
    throw new _appError.AppError({
      code: 'NoSourceMap',
    });
  }

  return {
    consumer,
    codeFileContent,
  };
}
/** Calculate the number of bytes contributed by each source file */

function computeGeneratedFileSizes(sourceMapData) {
  const spans = computeSpans(sourceMapData);
  const files = {};
  let unmappedBytes = 0;
  let totalBytes = 0;

  for (let i = 0; i < spans.length; i++) {
    const { numChars, source } = spans[i];
    totalBytes += numChars;

    if (source === null) {
      unmappedBytes += numChars;
    } else {
      files[source] = (files[source] || 0) + numChars;
    }
  }

  return {
    files,
    unmappedBytes,
    totalBytes,
  };
}

function computeSpans(sourceMapData) {
  const { consumer, codeFileContent } = sourceMapData;
  const lines = codeFileContent.split('\n');
  const spans = [];
  let numChars = 0;
  let lastSource = undefined; // not a string, not null

  for (let line = 1; line <= lines.length; line++) {
    const lineText = lines[line - 1];
    const numCols = lineText.length;

    for (let column = 0; column < numCols; column++, numChars++) {
      const { source } = consumer.originalPositionFor({
        line,
        column,
      });

      if (source !== lastSource) {
        lastSource = source;
        spans.push({
          source,
          numChars: 1,
        });
      } else {
        spans[spans.length - 1].numChars += 1;
      }
    }
  }

  return spans;
}

function adjustSourcePaths(fileSizeMap, options) {
  if (!options.noRoot) {
    const prefix = (0, _helpers.getCommonPathPrefix)(Object.keys(fileSizeMap));
    const length = prefix.length;

    if (length) {
      fileSizeMap = (0, _lodash.mapKeys)(fileSizeMap, (size, source) => source.slice(length));
    }
  }

  if (options.replaceMap) {
    fileSizeMap = Object.entries(options.replaceMap).reduce((result, [before, after]) => {
      const regexp = new RegExp(before, 'g');
      return (0, _lodash.mapKeys)(result, (size, source) => source.replace(regexp, after));
    }, fileSizeMap);
  }

  return fileSizeMap;
}
